#!markdown

# Security in Powershell

## Obvious Stuff
1) Lock down permissions to your solutions
    1) Having poor permissioning on your scripts can lead to edits and secrets being leaked.
1) Be careful code injection
    1) Be careful with user input in general
    1) Invoke-Experssion
    1) injection hunter module (https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/)
    1) Management.Automation.Language.CodeGeneration - Methods to escape common injection attacks
1) Beware of Over-The-Shoulder Logging
    1) Event log tracks your scripts (Protected Event logging)
    1) Command lines can be seen in Task Manager

#!pwsh

[Management.Automation.Language.CodeGeneration]::EscapeSingleQuotedStringContent("Test'string")
[Management.Automation.Language.CodeGeneration]::EscapeBlockCommentContent("Test#>string")

#!pwsh

$username = 'Administrator'
$Password = 'P@ssw0rd'
Powershell.exe -command " Invoke-Command {([void]('$username : $Password'))};Start-sleep -Seconds 15 " 

#!pwsh

$username = 'Administrator'
$Password = 'P@ssw0rd'
$Cred = [PScredential]::new($username, (ConvertTo-SecureString -String $Password -AsPlainText -Force))
Get-WinEvent -LogName Microsoft-Windows-PowerShell/Operational -MaxEvents 20 | where {$PSItem.message -like '*P@ss*'}   
Get-WinEvent -LogName 'Windows PowerShell' -MaxEvents 20 | where {$PSItem.message -like '*P@ss*'}   

#EventVwr.msc
# 800

#!markdown

## Secrets management platform
 1) https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.secretmanagement/?view=ps-modules
 2) Not a lot of options yet

#!pwsh

# Install-Module Microsoft.PowerShell.SecretManagement -Scope CurrentUser -force
# Register-SecretVault -Name LocalStore -ModuleName Microsoft.PowerShell.SecretStore  -DefaultVault
# Reset-SecretStore
$Password = 'P@ssw0rd'
Set-Secret -Name TestUser -Secret $Password
$Secret = Get-Secret -Name Testuser
[System.Runtime.InteropServices.marshal]::PtrToStringAuto([System.Runtime.InteropServices.marshal]::SecureStringToBSTR($Secret))

#!markdown

## GO it alone Secrets
    1) There are a lot of tricks to secure your passwords, tokens and other secrets. 
    1) Security is never perfect but that does not mean you can do nothing to secure secrets.
    1) Separating secrets like usernames from passwords is a good idea. 
    1) https://github.com/PowerShell/SecretManagement/tree/master/ExtensionModules


### DPAPI
    1) Data Protection API is a good solution for some solutions based on AES encryption and built into windows. 
        1) User Keys:  %userprofile%\AppData\Roaming\Microsoft\Protect
        1) Computer Keys: %windir%\system32\microsoft\protect
    1) DPAPI is easy to use. 
        1) Browser secrets
        1) Biometrics data
        1) Credential Manager
    1) Breaks the secret into two peices: The encrypted payload and the user's password
    1) Anyone can decrypt with the user's context

#!pwsh

#Encrypt DPAPI

$secure = ConvertTo-SecureString -String â€˜Password123' -AsPlainText -Force 
$SecureString  = ConvertFrom-SecureString -SecureString $secure
$SecureString

#!pwsh

# Decoding DPAPI

$securestring = ConvertTo-SecureString -String $SecureString
$Cred = [PSCredential]::New('User',$SecureString)
$Cred
$Cred.GetNetworkCredential().password

#!markdown

### Symmetric Encryption
1) You pass in the Key used to encrypt and decrypt the secret.
1) Breaks the secret into two pieces: The encrypted payload and the key 

#!pwsh

# Encoding symmetric  

$Userinput = 'someParam2Secure'
$keybytes = [System.Text.Encoding]::UTF8.GetBytes($Userinput)
[Byte[]] $Key = [System.Security.Cryptography.HashAlgorithm]::Create('SHA256').ComputeHash($keybytes)

$secure = ConvertTo-SecureString -String 'Password123' -AsPlainText -Force 
ConvertFrom-SecureString -SecureString $secure -Key $key

#!pwsh

# Decoding symmetric
$securestring = ConvertTo-SecureString -Key $key -String '76492d1116743f0423413b16050a5345MgB8AEcAaABEAE4AZgAyAG0ASgBJADgAMABoAGwASQBIACsAMQBRAGMAbQBmAGcAPQA9AHwAZQAwADEAZgAzADcAOQBlADkAOAAyAGYAOQAzAGQAOQBhAGMAZQBiAGUANgBlAGEAYQA3ADgANAAzADUAYQAxAGMAMQBhAGIAYQA2ADYAYgAyADkANABjAGYAZQBkAGYAZQAyADUAMQBmADcAZAAwAGQAMgA3ADIANgBmADMANgA='
[System.Runtime.InteropServices.marshal]::PtrToStringAuto([System.Runtime.InteropServices.marshal]::SecureStringToBSTR($securestring))

#!markdown

## Code Signing 

1) Code signing effectively pervent script changes on your scripts.
1) Not all tools supports scripts being signed.
1) Needs to be partnered with policy to enforce execution policy.

#!markdown

$authenticode = New-SelfSignedCertificate -Subject "CustomSigning" -CertStoreLocation Cert:\CurrentUser\my -Type CodeSigningCert
